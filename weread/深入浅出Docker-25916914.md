---
doc_type: weread-highlights-reviews
bookId: "25916914"
reviewCount: 0
noteCount: 43
author:
  - 奈吉尔·波尔顿
  - 人民邮电出版社
cover: https://cdn.weread.qq.com/weread/cover/21/YueWen_25916914/t7_YueWen_25916914.jpg
readingStatus: 在读
progress: 60%
totalReadDay: 3
readingTime: 0小时59分钟
readingDate: 2021-12-23
title: 深入浅出Docker
published: 2019-04-01 00:00:00
isbn: 9787115504890
tags:
  - weread/计算机-计算机综合
type: weread-notes
weread: https://weread.qq.com/web/reader/a6332ce0718b75f2a63b772

---


## 封面

## 版权信息

## 版权

## 版权声明

## 内容提要

## 前言

> [!NOTE] 
> 本篇介绍Docker公司（Docker, Inc.）、Docker（Moby）项目、什么是OCI、为什么需要容器
> 
> 2022-03-10 17:31:26 ^25916914-6-2347-2403

> [!NOTE] 
> TLS、RBAC、与AD的集成，以及备份
> 
> 2022-03-10 17:31:48 ^25916914-6-2569-2589

## 资源与支持

## 第一部分 Docker概览

### 第2章 走进Docker

### 第3章 Docker安装

### 第4章 纵观Docker

> [!NOTE] 
> ● 运维（Ops）视角。● 开发（Dev）视角。
> 
> 2022-06-02 14:09:39 ^25916914-11-478-533

> [!NOTE] 
> 读者只需一个可连接到互联网的Docker主机
> 
> 2022-06-02 14:10:24 ^25916914-11-960-982

> [!NOTE] 
> Play With Docker（PWD）
> 
> 2022-06-02 14:10:44 ^25916914-11-1153-1174

> [!NOTE] 
> Docker客户端和Docker daemon（有时也被称为“服务端”或者“引擎”）。
> 
> 2022-06-02 14:23:16 ^25916914-11-1376-1419

> [!NOTE] 
> 使用Linux默认安装时，客户端与daemon之间的通信是通过本地IPC/UNIX Socket完成的（/var/run/docker.sock）；在Windows上是通过名为npipe:////./pipe/docker_engine的管道（pipe）完成的
> 
> 2022-06-02 14:23:30 ^25916914-11-1489-1619

> [!NOTE] 
> docker version命令来检测客户端和服务端是否都已经成功运行，并且可以互相通信
> 
> 2022-06-02 14:46:08 ^25916914-11-1626-1670

> [!NOTE] 
> 如果加上sudo之后命令正常运行，那么读者需要将当前用户加入到docker用户组，或者给本书后面的命令都加上sudo前缀。
> 
> 2022-06-02 14:53:32 ^25916914-11-2286-2347

> [!NOTE] 
> OS文件系统和应用的对象
> 
> 2022-06-02 15:05:35 ^25916914-11-2454-2466

> [!NOTE] 
> 虚拟机模板本质上是处于关机状态的虚拟机
> 
> 2022-06-02 15:06:13 ^25916914-11-2495-2514

> [!NOTE] 
> 在Docker世界中，镜像实际上等价于未运行的容器。如果读者是一名开发者，可以将镜像比作类（Class）。
> 
> 2022-06-02 15:06:21 ^25916914-11-2515-2568

> [!NOTE] 
> Windows Nano Server
> 
> 2022-06-02 15:09:58 ^25916914-11-3760-3779

> [!NOTE] 
> 用户可以通过引用镜像的ID或名称来使用镜像
> 
> 2022-06-02 15:10:20 ^25916914-11-3937-3958

> [!NOTE] 
> 这是因为-it参数会将Shell切换到容器终端——现在已经位于容器内部了！
> 
> 2022-06-02 15:10:48 ^25916914-11-4583-4620

> [!NOTE] 
> 在容器内部运行ps命令查看当前正在运行的全部进程
> 
> 2022-06-02 15:11:20 ^25916914-11-4973-4997

> [!NOTE] 
> 这是由 Windows 操作系统工作方式决定的
> 
> 2022-06-02 15:12:19 ^25916914-11-6951-6974

> [!NOTE] 
> <SNIP>
> 
> 2022-06-02 15:14:50 ^25916914-11-8752-8760

> [!NOTE] 
> Ctrl-PQ
> 
> 2022-06-02 15:23:15 ^25916914-11-9305-9312

> [!NOTE] 
> 执行docker container exec命令，可以将Shell连接到一个运行中的容器终端。
> 
> 2022-06-02 15:23:32 ^25916914-11-9785-9833

> [!NOTE] 
> 通过docker container stop和docker container rm命令来停止并杀死容器。
> 
> 2022-06-02 15:24:26 ^25916914-11-11093-11147

## 第二部分 Docker技术

### 第6章 Docker镜像

> [!NOTE] 
> 镜像可以理解为一种构建时（build-time）结构，而容器可以理解为一种运行时（run-time）结构
> 
> 2022-03-10 17:34:10 ^25916914-13-1292-1344

> [!NOTE] 
> Docker镜像通常不会包含6个不同的Shell让读者选择——通常Docker镜像中只有一个精简的Shell，甚至没有Shell。镜像中还不包含内核——容器都是共享所在Docker主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象）
> 
> 2022-03-10 17:34:38 ^25916914-13-2286-2419

### 第7章 Docker容器

### 第8章 应用的容器化

### 第9章 使用Docker Compose部署应用

> [!NOTE] 
> Docker Compose，它能够在Docker节点上，以单引擎模式（Single-Engine Mode）进行多容器应用的部署和管理。
> 
> 2022-06-02 15:33:28 ^25916914-16-478-547

> [!NOTE] 
> Swarm模
> 
> 2022-06-02 15:33:35 ^25916914-16-570-576

> [!NOTE] 
> 通过一个声明式的配置文件描述整个应用，从而使用一条命令完成部署
> 
> 2022-06-02 15:34:04 ^25916914-16-1229-1260

> [!NOTE] 
> Fig
> 
> 2022-06-02 15:34:31 ^25916914-16-1878-1881

> [!NOTE] 
> Orchard公司
> 
> 2022-06-02 15:34:34 ^25916914-16-1889-1898

> [!NOTE] 
> Fig是一个基于Docker的Python工具，允许用户基于一个YAML文件定义多容器应用，从而可以使用fig命令行工具进行应用的部署。Fig还可以对应用的全生命周期进行管理
> 
> 2022-06-02 15:34:53 ^25916914-16-1925-2012

> [!NOTE] 
> Docker for Windows, DfW
> 
> 2022-06-02 15:36:59 ^25916914-16-2778-2801

> [!NOTE] 
> YAML是JSON的一个子集，因此也可以使用JSON
> 
> 2022-06-02 15:37:34 ^25916914-16-5752-5778

> [!NOTE] 
> 它包含4个一级key：version、services、networks、volumes。
> 
> 2022-06-02 16:26:29 ^25916914-16-6492-6537

> [!NOTE] 
> version是必须指定的，而且总是位于文件的第一行。它定义了Compose文件格式（主要是API）的版本。建议使用最新版本。
> 
> 2022-06-02 16:26:39 ^25916914-16-6606-6669

> [!NOTE] 
> Docker Compose会创建bridge网络。这是一种单主机网络，只能够实现同一主机上容器的连接。当然，也可以使用driver属性来指定不同的网络类型
> 
> 2022-06-02 16:27:46 ^25916914-16-7058-7136

> [!NOTE] 
> 定义了两个服务，一个名为counter-net的网络和一个名为counter-vol的卷
> 
> 2022-06-02 16:28:40 ^25916914-16-7480-7524

> [!NOTE] 
> Docker Compose会将每个服务部署为一个容器，并且会使用key作为容器名字的一部分
> 
> 2022-06-02 16:29:01 ^25916914-16-7690-7736

> [!NOTE] 
> 指定Docker将容器内（-target）的5000端口映射到主机（published）的5000端口
> 
> 2022-06-02 16:29:31 ^25916914-16-8138-8189

> [!NOTE] 
> 综上，Docker Compose会调用Docker来为web-fe服务部署一个独立的容器。该容器基于与Compose文件位于同一目录下的Dockerfile构建的镜像。基于该镜像启动的容器会运行app.py作为其主程序，将5000端口暴露给宿主机，连接到counter-net网络上，并挂载一个卷到/code。
> 
> 2022-06-02 16:30:40 ^25916914-16-8596-8752

> [!NOTE] 
> 由于两个服务都连接到counter-net网络，因此它们可以通过名称解析到对方的地址。
> 
> 2022-06-02 16:31:17 ^25916914-16-9288-9331

> [!NOTE] 
> 默认情况下，docker-compose up会查找名为docker-compose.yml或docker-compose.yaml的Compose文件。如果Compose文件是其他文件名，则需要通过-f参数来指定。
> 
> 2022-06-02 16:31:51 ^25916914-16-11037-11145

### 第10章 Docker Swarm

### 第11章 Docker网络

> [!NOTE] 
> 容器网络模型（CNM）
> 
> 2022-03-10 17:52:11 ^25916914-18-27105-27116

### 第12章 Docker覆盖网络

### 第13章 卷与持久化数据

> [!NOTE] 
> 如果希望自己的容器数据保留下来（持久化），则需要将数据存储在卷上。卷与容器是解耦的，从而可以独立地创建并管理卷，并且卷并未与任意容器生命周期绑定。最终效果即用户可以删除一个关联了卷的容器，但是卷并不会被删除
> 
> 2022-03-10 17:39:31 ^25916914-20-921-1024

> [!NOTE] 
> 通常与微服务挂钩的词有暂时以及无状态。所以，微服务就是无状态的、临时的工作负载，同时容器即微服务
> 
> 2022-03-12 14:41:31 ^25916914-20-1167-1215

### 第14章 使用Docker Stack部署应用

### 第15章 Docker安全

### 第16章 企业版工具

### 第17章 企业级特性

## 附录A 安全客户端与daemon的通信

## 附录B DCA考试

## 附录C 延伸


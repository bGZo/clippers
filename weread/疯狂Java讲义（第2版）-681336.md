---
doc_type: weread-highlights-reviews
bookId: "681336"
reviewCount: 2
noteCount: 89
author:
  - 李刚编著
  - 电子工业出版社
cover: https://cdn.weread.qq.com/weread/cover/23/YueWen_681336/t7_YueWen_681336.jpg
readingStatus: 读完
progress: 99%
totalReadDay: 13
readingTime: 16小时51分钟
readingDate: 2021-12-23
finishedDate: 2022-12-05
title: 疯狂Java讲义（第2版）
published: 2012-01-01 00:00:00
isbn: 9787121155789
tags:
  - weread/计算机-编程设计
type: weread-notes
weread: https://weread.qq.com/web/reader/239324a05a6578239cd415d

---


## 封面

## 版权信息

## 如何学习Java

## 光盘说明

## 前言

## 第1章 Java语言概述

### 1.1 Java语言的发展简史

### 1.2 Java的竞争对手及各自优势

### 1.3 Java程序运行机制

### 1.4 开发Java的准备

### 1.5 第一个Java程序

### 1.6 Java程序的基本规则

### 1.7 垃圾回收机制

### 1.8 何时开始使用IDE工具

### 1.9 本章小结

## 第2章 理解面向对象

### 2.1 面向对象

### 2.2 UML（统一建模语言）介绍

### 2.3 Java的面向对象特征

### 2.4 本章小结

## 第3章 数据类型和运算符

### 3.1 注释

### 3.2 标识符和关键字

### 3.3 数据类型分类

### 3.4 基本数据类型

### 3.5 基本类型的类型转换

### 3.6 直接量

### 3.7 运算符

### 3.8 本章小结

## 第4章 流程控制与数组

### 4.1 顺序结构

### 4.2 分支结构

### 4.3 循环结构

### 4.4 控制循环结构

### 4.5 数组类型

### 4.6 深入数组

### 4.7 本章小结

## 第5章 面向对象（上）

### 5.1 类和对象

### 5.2 方法详解

### 5.3 成员变量和局部变量

### 5.4 隐藏和封装

### 5.5 深入构造器

### 5.6 类的继承

### 5.7 多态

### 5.8 继承与组合

### 5.9 初始化块

> [!NOTE] 
> 初始化块的修饰符只能是static，使用static修饰的初始化块被称为静态初始化块
> 
> 2022-11-25 10:43:39 ^681336-47-1060-1102

> [!NOTE] 
> 普通初始化块、声明实例Field指定的默认值都可认为是对象的初始化代码，它们的执行顺序与源程序中的排列顺序相同
> 
> 2022-11-25 17:00:13 ^681336-47-2962-3017

> [!NOTE] 
> 初始化块是一段固定执行的代码，它不能接收任何参数
> 
> 2022-11-25 17:16:17 ^681336-47-4184-4208

> [!NOTE] 
> 如果有一段初始化处理代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到初始化块中
> 
> 2022-11-25 17:16:54 ^681336-47-4260-4313

> [!NOTE] 
> 如果希望类加载后对整个类进行某些初始化操作，例如当Person类加载后，则需要把Person类的eyeNumber类Field初始化为2，此时需要使用static关键字来修饰初始化块，使用static修饰的初始化块被称为静态初始化块
> 
> 2022-11-25 17:21:08 ^681336-47-4967-5083

### 5.10 本章小结

## 第6章 面向对象（下）

### 6.1 Java 7增强的包装类

> [!NOTE] 
> 这8种基本数据类型不支持面向对象的编程机制，基本数据类型的数据也不具备“对象”的特性：没有Field、方法可以被调用。Java之所以提供这8种基本数据类型，主要是为了照顾程序员传统的习惯
> 
> 2022-11-25 18:04:49 ^681336-50-491-584

> [!NOTE] 
> 例如所有引用类型的变量都继承了Object类，都可当成Object类型变量使用。但基本数据类型的变量就不可以，如果有个方法需要Object类型的参数，但实际需要的值却是2、3等数值，这可能就比较难以处理
> 
> 2022-11-26 10:35:12 ^681336-50-672-773

> [!NOTE] 
> 当试图使用一个字符串来创建Boolean对象时，如果传入的字符串是"true"，或是此字符串不同字母的大小写变化形式，如"True"，都将创建true对应的Boolean对象；如果传入其他字符串，则会创建false对应的Boolean对象
> 
> 2022-11-26 10:41:13 ^681336-50-2638-2757

> [!NOTE] 
> int类型变量只能自动装箱成Integer对象（即使赋给Object类型变量，那也只是利用了Java的向上自动转型特性），不要试图装箱成Boolean对象
> 
> 2022-11-26 10:57:25 ^681336-50-4727-4804

> [!NOTE] 
> 系统把一个-128～127之间的整数自动装箱成Integer实例，并放入了一个名为cache的数组中缓存起来。如果以后把一个-128～127之间的整数自动装箱成一个Integer实例时，实际上是直接指向对应的数组元素，因此-128～127之间的同一个整数自动装箱成Integer实例时，永远都是引用cache数组的同一个数组元素，所以它们全部相等；但每次把一个不在-128～127范围内的整数自动装箱成Integer实例时，系统总是重新创建一个Integer实例，所以出现程序中的运行结果
> 
> 2022-11-26 17:29:43 ^681336-50-8883-9127

### 6.2 处理对象

> [!NOTE] 
> 而Person实例是一个内存中的对象，当使用该方法输出Person对象时，实际上输出的是Person对象的toString()方法的返回值。也就是说，下面两行代码的效果完全一样
> 
> 2022-11-26 18:03:33 ^681336-51-1793-1881

> [!NOTE] 
> toString方法是一个非常特殊的方法，它是一个“自我描述”方法，该方法通常用于实现这样一个功能：当程序员直接打印该对象时，系统将会输出该对象的“自我描述”信息，用以告诉外界该对象具有的状态信息。
> 
> 2022-11-26 18:03:50 ^681336-51-2410-2509

> [!NOTE] 
> equals方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量相等。但使用这个方法判断两个对象相等的标准与使用==运算符没有区别，同样要求两个引用变量指向同一个对象才会返回true。因此这个Object类提供的equals方法没有太大的实际意义，如果希望采用自定义的相等标准，则可采用重写equals方法来实现
> 
> 2022-11-26 18:18:32 ^681336-51-8334-8511

### 6.3 类成员

> [!NOTE] 
> 当通过对象来访问类Field时，系统会在底层转换为通过该类来访问类Field
> 
> 2022-11-26 19:05:55 ^681336-52-1283-1321

> [!NOTE] 
> 从程序运行表面来看，即可看到同一类的所有实例的类Field共享同一块内存区
> 
> 2022-11-26 19:07:41 ^681336-52-1580-1617

> [!NOTE] 
> 与类Field类似，即使使用对象来调用类方法，其效果也与采用类来调用类方法完全一样
> 
> 2022-11-26 19:09:36 ^681336-52-1703-1744

> [!NOTE] 
> 实际上依然是委托给该类来访问类成员，因此即使某个实例为null，它也可以访问它所属类的类成员
> 
> 2022-11-26 19:09:47 ^681336-52-1787-1833

> [!NOTE] 
> 因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误
> 
> 2022-11-26 19:13:19 ^681336-52-2946-3029

> [!NOTE] 
> 在大部分时候，我们把类的构造器定义成public访问权限，允许任何类自由创建该类的对象
> 
> 2022-11-26 19:15:48 ^681336-52-3264-3307

### 6.4 final修饰符

> [!NOTE] 
> 如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的0、'\u0000'、false或null，这些成员变量也就完全失去了存在的意义
> 
> 2022-11-27 11:27:57 ^681336-53-1272-1376

> [!NOTE] 
> final修饰的成员变量必须由程序员显式地指定初始值
> 
> 2022-11-27 11:28:00 ^681336-53-1388-1414

> [!NOTE] 
> 类Field：必须在静态初始化块中或声明该Field时指定初始值。[插图] 实例Field：必须在非静态初始化块、声明该Field或构造器中指定初始值
> 
> 2022-11-27 11:28:13 ^681336-53-1646-1879

> [!NOTE] 
> 系统不会对final成员进行隐式初始化
> 
> 2022-11-27 11:45:32 ^681336-53-4361-4380

> [!NOTE] 
> 当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变
> 
> 2022-11-27 12:07:32 ^681336-53-6874-6995

> [!NOTE] 
> 程序最后两行代码分别判断book、book2和“疯狂Java讲义：99.0”是否相等。由于book是一个“宏变量”，它将被直接替换成“疯狂Java讲义：99.0”，因此book和“疯狂Java讲义：99.0”相等，但book2和该字符串不相等
> 
> 2022-11-27 13:25:34 ^681336-53-11528-11649

> [!NOTE] 
> Java提供的Object类里就有一个final方法：getClass()，因为Java不希望任何类重写这个方法，所以使用final把这个方法密封起来
> 
> 2022-11-27 13:26:30 ^681336-53-13740-13815

> [!NOTE] 
> 也不是方法重写，只是重新定义了一个新方法
> 
> 2022-11-27 13:27:05 ^681336-53-14489-14509

> [!NOTE] 
> final修饰的方法仅仅是不能被重写，并不是不能被重载，因此下面程序完全没有问题。
> 
> 2022-11-27 13:27:52 ^681336-53-15165-15206

> [!NOTE] 
> final修饰的类不可以有子类
> 
> 2022-11-27 13:28:05 ^681336-53-15657-15672

> [!NOTE] 
> 不可变（immutable）类的意思是创建该类的实例后，该实例的Field是不可改变的
> 
> 2022-11-27 13:30:40 ^681336-53-16334-16377

> [!NOTE] 
> Java提供的8个包装类和java.lang.String类都是不可变类，当创建它们的实例后，其实例的Field不可改变
> 
> 2022-11-27 13:30:51 ^681336-53-16378-16438

> [!NOTE] 
> 如果需要创建自定义的不可变类，可遵守如下规则。[插图] 使用private和final修饰符来修饰该类的Field。[插图] 提供带参数构造器，用于根据传入参数来初始化类里的Field。[插图] 仅为该类的Field提供getter方法，不要为该类的Field提供setter方法，因为普通方法无法修改final修饰的Field。[插图] 如果有必要，重写Object类的hashCode和equals方法。equals方法以关键Field来作为判断两个对象是否相等的标准，除此之外，还应该保证两个用equals方法判断为相等的对象的hashCode也相等。例如，java.lang.String这个类就做得很好，它就是根据String对象里的字符序列来作为相等的标准，其hashCode方法也是根据字符序列计算得到的。
> 
> 2022-11-27 13:31:49 ^681336-53-16814-17835

> [!NOTE] 
> 可变类的含义是该类的实例Field是可变的。大部分时候所创建的类都是可变类，特别是JavaBean，因为总是为其Field提供了setter和getter方法
> 
> 2022-11-27 13:34:01 ^681336-53-20592-20671

> [!NOTE] 
> 与可变类相比，不可变类的实例在整个生命周期中永远处于初始化状态，它的Field不可改变。因此对不可变类的实例的控制将更加简单。
> 
> 2022-11-27 13:34:07 ^681336-53-20701-20764

> [!NOTE] 
> ：当创建不可变类时，如果它包含Field的类型是可变的，那么其对象的Field值依然是可改变的——这个不可变类其实是失败的
> 
> 2022-11-27 13:56:30 ^681336-53-20874-20935

> [!NOTE] 
> 为了保持Person对象的不可变性，必须保护好Person对象的引用类型Field：name，让程序无法访问到Person对象的name Field，也就无法利用name Field的可变性来改变Person对象了
> 
> 2022-11-27 13:57:50 ^681336-53-22882-22989

> [!NOTE] 
> 该构造器创建Person对象时并不是直接利用已有的Name对象（利用已有的Name对象有风险，因为这个已有的Name对象是可变的，如果程序改变了这个Name对象，将会导致Person对象也发生变化），而是重新创建了一个Name对象来赋给Person对象的name Field
> 
> 2022-11-27 13:58:21 ^681336-53-23804-23941

> [!NOTE] 
> 6.4.8 缓存实例的不可变类
> 
> 2022-11-27 14:00:00 ^681336-53-24452-24467

> [!NOTE] 
> 深入讨论
> 
> 2022-11-27 13:58:46 ^681336-53-24707-24711

> [!NOTE] 
> 是否需要隐藏CacheImmutale类的构造器完全取决于系统需求。盲目乱用缓存也可能导致系统性能下降，缓存的对象会占用系统内存，如果某个对象只使用一次，重复使用的概率不大，缓存该实例就弊大于利；反之，如果某个对象需要频繁地重复使用，缓存该实例就利大于弊。
> 
> 2022-11-27 13:59:48 ^681336-53-28201-28329

### 6.5 抽象类

> [!NOTE] 
> 这不是一个好思路：假设有一个Shape引用变量，该变量实际上引用到Shape子类的实例，那么这个Shape变量就无法调用calPerimeter()方法，必须将其强制类型转换为其子类类型，才可调用calPerimeter()方法，这就降低了程序的灵活性
> 
> 2022-11-27 14:02:50 ^681336-54-724-850

> [!NOTE] 
> ，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法
> 
> 2022-11-27 14:03:47 ^681336-54-1213-1243

> [!NOTE] 
> [插图] 抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体。[插图] 抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。[插图] 抽象类可以包含Field、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类、枚举类6种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。[插图] 含有抽象方法的类（包括直接定义了一个抽象方法；继承了一个抽象父类，但没有完全实现父类包含的抽象方法，以及实现了一个接口，但没有完全实现接口包含的抽象方法3种情况）只能被定义成抽象类。
> 
> 2022-11-27 14:04:05 ^681336-54-1317-2232

> [!NOTE] 
> 抽象方法和空方法体的方法不是同一个概念。例如，public abstract void test();是一个抽象方法，它根本没有方法体，即方法定义后面没有一对花括号；但public void test(){}方法是一个普通方法，它已经定义了方法体，只是方法体为空，即它的方法体什么也不做，因此这个方法不可使用abstract来修饰
> 
> 2022-11-27 14:04:48 ^681336-54-2620-2785

> [!NOTE] 
> 抽象类不能用于创建实例，只能当作父类被其他子类继承。
> 
> 2022-11-27 14:05:38 ^681336-54-3890-3916

> [!NOTE] 
> 由于在Shape类中定义了calPerimeter ()方法和getType()方法，所以程序可以直接调用s1变量和s2变量的calPerimeter ()方法和getType()方法，无须强制类型转换为其子类类型
> 
> 2022-11-27 14:06:23 ^681336-54-6641-6748

> [!NOTE] 
> 利用抽象类和抽象方法的优势，我们可以更好地发挥多态的优势，使得程序更加灵活
> 
> 2022-11-27 14:06:30 ^681336-54-6778-6815

### 6.6 更彻底的抽象：接口

> [!NOTE] 
> 当我们说PCI接口时，指的是主机板上那个插槽遵守了PCI规范，而具体的PCI插槽只是PCI接口的实例
> 
> 2022-11-27 14:07:40 ^681336-55-836-886

> [!NOTE] 
> 接口体现的是规范和实现分离的设计哲学。
> 
> 2022-11-27 14:09:51 ^681336-55-1280-1299

> [!NOTE] 
> 修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口。[插图] 接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵守Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。[插图] 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。
> 
> 2022-11-27 14:10:17 ^681336-55-2550-3077

> [!NOTE] 
> 接口里可以包含Field （只能是常量）、方法（只能是抽象实例方法）、内部类（包括内部接口、枚举）定义
> 
> 2022-11-27 14:10:31 ^681336-55-3139-3190

> [!NOTE] 
> 对于接口里定义的方法而言，它们只能抽象方法，因此系统会自动为其增加abstract修饰符；由于接口里的方法全部是抽象方法，因此接口里不允许定义静态方法，即不可使用static修饰接口里定义的方法。不管定义接口里方法时是否使用public abstract修饰符，接口里的方法总是使用public abstract来修饰
> 
> 2022-11-27 14:11:06 ^681336-55-3911-4070

> [!NOTE] 
> 接口里定义的内部类、接口、枚举类默认都采用public static两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static对它们进行修饰。
> 
> 2022-11-27 14:11:16 ^681336-55-4169-4254

> [!NOTE] 
> 接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其实现类的对象
> 
> 2022-11-27 14:12:39 ^681336-55-7588-7651

> [!NOTE] 
> 接口和抽象类很像，它们都具有如下特征。[插图] 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。[插图] 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。
> 
> 2022-11-27 14:13:32 ^681336-55-11147-11573

> [!NOTE] 
> 除此之外，接口和抽象类在用法上也存在如下差别。[插图] 接口里只能包含抽象方法，不包含已经提供实现的方法；抽象类则完全可以包含普通方法。[插图] 接口里不能定义静态方法；抽象类里可以定义静态方法。[插图] 接口里只能定义静态常量Field，不能定义普通Field；抽象类里则既可以定义普通Field，也可以定义静态常量Field。[插图] 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。[插图] 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。[插图] 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。
> 
> 2022-11-27 14:13:27 ^681336-55-12187-13470

### 6.7 内部类

> [!NOTE] 
> 。Java从JDK 1.1开始引入内部类，内部类主要有如下作用。[插图] 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。假设需要创建Cow类，Cow类需要组合一个CowLeg对象，CowLeg类只有在Cow类里才有效，离开了Cow类之后没有任何意义。在这种情况下，就可把CowLeg定义成Cow的内部类，不允许其他类访问CowLeg。[插图] 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以互相访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量。[插图] 匿名内部类适合用于创建那些仅需要一次使用的类。对于前面介绍的命令模式，当需要传入一个Command对象时，重新专门定义PrintCommand和AddCommand两个实现类可能没有太大的意义，因为这两个实现类可能仅需要使用一次。在这种情况下，使用匿名内部类将更方便。
> 
> 2022-11-27 14:13:57 ^681336-56-552-1437

### 6.8 枚举类

### 6.9 对象与垃圾回收

### 6.10 修饰符的适用范围

### 6.11 使用JAR文件

### 6.12 本章小结

## 第7章 与运行环境交互

### 7.1 与用户互动

### 7.2 系统相关

### 7.3 常用类

### 7.4 处理日期的类

### 7.5 正则表达式

### 7.6 国际化与格式化

### 7.7 本章小结

## 第8章 Java集合

### 8.1 Java集合概述

### 8.2 Collection和Iterator接口

> [!NOTE] 
> 编译上面程序时，系统可能输出一些警告（warning）提示，这些警告提醒用户没有使用泛型（Generic）来限制集合里的元素类型，读者现在暂时不要理会这些警告，我们会在第9章详细介绍泛型编程
> 
> 2022-11-30 13:14:50 ^681336-72-5718-5813

> [!NOTE] 
> 在普通情况下，当我们把一个对象“丢进”集合中后，集合会忘记这个对象的类型——也就是说，系统把所有的集合元素都当成Object类的实例进行处理。从JDK 1.5以后，这种状态得到了改进：可以使用泛型来限制集合里元素的类型，并让集合记住所有集合元素的类型
> 
> 2022-11-30 13:15:14 ^681336-72-6143-6268

### 8.3 Set集合

> [!NOTE] 
> 每个元素的hashCode值就可以决定它的存储“索引”
> 
> 2022-11-28 16:08:38 ^681336-73-6297-6324

> [!NOTE] 
> HashSet采用每个元素的hashCode值来计算其索引，从而可以自由增加HashSet的长度，并可以根据元素的hashCode值来访问元素
> 
> 2022-11-28 16:09:01 ^681336-73-6440-6511

> [!NOTE] 
> 这将导致HashSet不可能准确访问该元素
> 
> 2022-11-30 17:01:31 ^681336-73-11522-11543

> [!NOTE] 
> 当向HashSet中添加可变对象时，必须十分小心。如果修改HashSet集合中的对象，有可能导致该对象与集合中的其他对象相等，从而导致HashSet无法准确访问该对象。
> 
> 2022-11-30 17:01:41 ^681336-73-11642-11726

> [!NOTE] 
> 一旦改变了TreeSet集合里可变元素的Field，当再试图删除该对象时，TreeSet也会删除失败（甚至集合中原有的、Field没被修改但与修改后元素相等的元素也无法删除）
> 
> 2022-11-30 17:34:59 ^681336-73-26621-26708

### 8.4 List集合

> [!NOTE] 
> List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引
> 
> 2022-11-28 15:23:38 ^681336-74-454-493

> [!NOTE] 
> 基于数组实现的List类
> 
> 2022-11-29 12:16:37 ^681336-74-9376-9388

> [!NOTE] 
> 实际上，Vector具有很多缺点，通常尽量少用Vector实现类。
> 
> 2022-11-29 12:21:22 ^681336-74-10971-11004

### 8.5 Queue集合

> [!NOTE] 
> PriorityQueue不允许插入null元素，它还需要对队列元素进行排序，PriorityQueue的元素有两种排序方式。
> 
> 2022-11-29 21:50:05 ^681336-75-3515-3578

> [!NOTE] 
> 随机访问集合元素时性能较差，但在插入、删除元素时性能非常出色（只需改变指针所指的地址即可）
> 
> 2022-11-29 23:16:25 ^681336-75-12401-12446

> [!NOTE] 
> 对于所有的内部基于数组的集合实现，例如ArrayList、ArrayDeque等，使用随机访问的性能比使用Iterator迭代访问的性能要好，因为随机访问会被映射成对数组元素的访问。
> 
> 2022-11-29 23:18:57 ^681336-75-12604-12695

> [!NOTE] 
> Java提供的List就是一个线性表接口，而ArrayList、LinkedList又是线性表的两种典型实现：基于数组的线性表和基于链的线性表。Queue代表了队列，Deque代表了双端队列（既可作为队列使用，也可作为栈使用）
> 
> 2022-11-29 23:20:49 ^681336-75-12935-13048

> [!NOTE] 
> 由于上面程序创建了一个长度为900000的字符串数组，需要很大的内存空间，JVM默认的内存空间不足以运行上面程序，所以应该采用如下命令来运行上面程序
> 
> 2022-11-29 23:41:45 ^681336-75-15572-15646

> [!NOTE] 
> 多次运行上面程序会发现，迭代ArrayList集合的时间略大于迭代LinkedList集合的时间。因此，关于使用List集合有如下建议。[插图] 如果需要遍历List集合元素，对于ArrayList、Vector集合，应该使用随机访问方法（get）来遍历集合元素，这样性能更好；对于LinkedList集合，则应该采用迭代器（Iterator）来遍历集合元素。[插图] 如果需要经常执行插入、删除操作来改变List集合的大小，则应该使用LinkedList集合，而不是ArrayList。使用ArrayList、Vector集合需要经常重新分配内部数组的大小，其时间开销常常是使用LinkedList的时间开销的几十倍，效果很差。[插图] 如果有多个线程需要同时访问List集合中的元素，开发者可考虑使用Collections将集合包装成线程安全的集合。
> 
> 2022-11-29 23:49:01 ^681336-75-16228-17079

### 8.6 Map

### 8.7 HashSet和HashMap的性能选项

### 8.8 操作集合的工具类：Collections

> [!NOTE] 
> 上面程序中用到了泛型（Generic）知识，如List<String>或LinkedList<String>等写法，它表示在List集合中只能放String类型的对象
> 
> 2022-11-30 12:52:50 ^681336-78-9526-9621

> [!NOTE] 
> 主要是因为梭哈游戏的规则较多（它分为对、三个、同花、顺子等），所以处理起来比较麻烦，读者可以一点一点地增加这些规则，只要该游戏符合自定义的规则，即表明这个游戏已经接近完成了
> 
> 2022-11-30 12:53:06 ^681336-78-9710-9796

### 8.9 烦琐的接口：Enumeration

> [!NOTE] 
> 在计算机行业有一条规则：加入任何规则都必须慎之又慎，因为以后无法删除规则
> 
> 2022-11-30 13:12:24 ^681336-79-1361-1397

### 8.10 本章小结

## 第9章 泛型

> [!NOTE] 
> ● 编译时类型检查的重要性● 使用泛型实现编译时进行类型检查
> 
> 2022-11-30 19:56:44 ^681336-81-508-608

### 9.1 泛型入门

> [!NOTE] 
> Object类型（其运行时类型没变）
> 
> 2022-11-30 21:24:41 ^681336-82-517-535

### 9.2 深入泛型

> [!NOTE] 
> 为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明
> 
> 2022-12-01 11:13:53 ^681336-83-4565-4595

### 9.3 类型通配符

> [!NOTE] 
> Java允许Integer[]数组赋值给Number[]变量显然不是一种安全的设计。
> 
> 2022-12-02 00:59:26 ^681336-84-3192-3234

> [!NOTE] 
> 程序依然可以访问集合c中的元素，其类型是Object，这永远是安全的，因为不管List的真实类型是什么，它包含的都是Object
> 
> 2022-12-02 01:19:10 ^681336-84-4542-4606

> [!NOTE] 
> 唯一的例外是null，它是所有引用类型的实例
> 
> 2022-12-02 01:24:56 ^681336-84-5249-5271

### 9.4 泛型方法

> [!NOTE] 
> 类型形参T产生的唯一效果是可以在不同的调用点传入不同的实际类型。对于这种情况，应该使用通配符：通配符就是被设计用来支持灵活的子类化的
> 
> 2022-12-02 12:28:26 ^681336-85-8593-8659

> [!NOTE] 
> 假定需要创建一个TreeSet<String>集合，并传入一个可以比较String大小的Comparator，这个Comparator既可以是Comparator<String>，也可以是Comparator<Object>——只要尖括号里传入的类型是String的父类型（或它本身）即可
> 
> 2022-12-02 12:55:45 ^681336-85-16431-16593

> [!NOTE] 
> 将所有可用的Comparator作为参数传入，从而增加了程序的灵活性。当然，不仅TreeSet有这种用法，TreeMap也有类似的用法，具体请查阅Java的API文档。
> 
> 2022-12-02 12:56:05 ^681336-85-18143-18227

### 9.5 擦除和转换

### 9.6 泛型与数组

> [!NOTE] 
> 通过instanceof运算符来保证它的数据类型
> 
> 2022-12-02 13:42:58 ^681336-87-2699-2723

> [!NOTE] 
> 创建元素类型是类型变量的数组对象也将导致编译错误
> 
> 2022-12-02 13:43:33 ^681336-87-3200-3224

### 9.7 本章小结

## 第10章 异常处理

### 10.1 异常概述

### 10.2 异常处理机制

### 10.3 Checked异常和Runtime异常体系

### 10.4 使用throw抛出异常

### 10.5 Java的异常跟踪栈

### 10.6 异常处理规则

> [!NOTE] 
> 异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分离，因此绝不要使用异常处理来代替正常的业务逻辑判断。
> 
> 2022-12-02 16:01:54 ^681336-95-3103-3164

### 10.7 本章小结

## 第11章 AWT编程

### 11.1 GUI（图形用户界面）和AWT

### 11.2 AWT容器

### 11.3 布局管理器

### 11.4 AWT常用组件

### 11.5 事件处理

### 11.6 AWT菜单

### 11.7 在AWT中绘图

### 11.8 处理位图

### 11.9 剪贴板

### 11.10 拖放功能

### 11.11 本章小结

## 第12章 Swing编程

### 12.1 Swing概述

### 12.2 Swing基本组件的用法

### 12.3 Swing中的特殊容器

### 12.4 Swing简化的拖放功能

### 12.5 Java 7新增的Swing功能

### 12.6 使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条

### 12.7 使用JSlider和BoundedRangeModel创建滑动条

### 12.8 使用JSpinner和SpinnerModel创建微调控制器

### 12.9 使用JList、JComboBox创建列表框

### 12.10 使用JTree和TreeModel创建树

### 12.11 使用JTable和TableModel创建表格

### 12.12 使用JFormattedTextField和JTextPane创建格式文本

### 12.13 本章小结

## 第13章 MySQL数据库与JDBC编程

### 13.1 JDBC基础

### 13.2 SQL语法

### 13.3 JDBC的典型用法

### 13.4 执行SQL语句的方式

### 13.5 管理结果集

### 13.6 Java 7的RowSet 1.1

### 13.7 事务处理

### 13.8 分析数据库信息

### 13.9 使用连接池管理连接

### 13.10 本章小结

## 第14章 Annotation（注释）

### 14.1 基本Annotation

### 14.2 JDK的元Annotation

### 14.3 自定义Annotation

### 14.4 编译时处理Annotation

### 14.5 本章小结

## 第15章 输入/输出

### 15.1 File类

### 15.2 理解Java的IO流

### 15.3 字节流和字符流

### 15.4 输入/输出流体系

### 15.5 重定向标准输入/输出

### 15.6 Java虚拟机读写其他进程的数据

### 15.7 RandomAccessFile

### 15.8 对象序列化

### 15.9 NIO

### 15.10 Java 7的NIO.2

### 15.11 本章小结

## 第16章 多线程

### 16.1 线程概述

### 16.2 线程的创建和启动

### 16.3 线程的生命周期

### 16.4 控制线程

### 16.5 线程同步

### 16.6 线程通信

### 16.7 线程组和未处理的异常

### 16.8 线程池

### 16.9 线程相关类

### 16.10 本章小结

## 第17章 网络编程

### 17.1 网络编程的基础知识

### 17.2 Java的基本网络支持

### 17.3 基于TCP协议的网络编程

### 17.4 基于UDP协议的网络编程

### 17.5 使用代理服务器

### 17.6 本章小结

## 第18章 类加载机制与反射

### 18.1 类的加载、连接和初始化

### 18.2 类加载器

### 18.3 通过反射查看类信息

> [!NOTE] 
> 值得指出的是，虽然我们定义ClassTest类时使用了@SuppressWarnings注释，但程序运行时无法分析出该类里包含的该注释，这是因为@SuppressWarnings使用了@Retention(value=SOURCE)修饰，这表明@SuppressWarnings只能保存在源代码级别上，而通过ClassTest.class获取该类的运行时Class对象，所以程序无法访问到@SuppressWarnings注释。
> 
> 2022-12-05 14:03:45 ^681336-173-16424-16638

### 18.4 使用反射生成并操作对象

### 18.5 使用反射生成JDK动态代理

### 18.6 反射和泛型

### 18.7 本章小结


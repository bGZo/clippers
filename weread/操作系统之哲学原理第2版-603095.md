---
doc_type: weread-highlights-reviews
bookId: "603095"
reviewCount: 0
noteCount: 7
author:
  - 邹恒明
  - 机械工业出版社
cover: https://cdn.weread.qq.com/weread/cover/87/YueWen_603095/t7_YueWen_603095.jpg
readingStatus: 在读
progress: 98%
totalReadDay: 1
readingTime: 0小时10分钟
readingDate: 2022-02-15
title: 操作系统之哲学原理第2版
published: 2012-03-12 00:00:00
isbn: 9787111366928
tags:
  - weread/计算机-计算机综合
type: weread-notes
weread: https://weread.qq.com/web/reader/9eb326d05933d79ebf22eb3

---


## 封面

## 版权信息

## 前言

## 第一篇 基础原理篇

### 第1章 操作系统导论

#### 1.1 人造与神造

#### 1.2 程序是如何运行的

#### 1.3 什么是操作系统

#### 1.4 魔术与管理

#### 1.5 用户程序与操作系统

#### 1.6 操作系统的范畴

#### 1.7 为什么学习操作系统

#### 思考题

### 第2章 操作系统历史

#### 2.1 第一阶段：状态机操作系统（1940年以前）

#### 2.2 第二阶段：单一操作员单一控制端操作系统（20世纪40年代）

#### 2.3 第三阶段：批处理操作系统（20世纪50年代）

#### 2.4 第四代：多道批处理操作系统（20世纪60年代）

#### 2.5 第五代之一：分时操作系统（20世纪70年代）

#### 2.6 第五代之二：实时操作系统

#### 2.7 第六代：现代操作系统（1980年以后）

#### 2.8 操作系统的演变过程

#### 2.9 操作系统的未来发展趋势

#### 2.10 讨论：操作系统虚拟化和虚拟化的操作系统

#### 思考题

### 第3章 操作系统基本概念

#### 3.1 计算机硬件基本知识

#### 3.2 抽象

#### 3.3 内核态和用户态

#### 3.4 操作系统结构

#### 3.5 进程、内存和文件

#### 3.6 系统调用

#### 3.7 壳

#### 思考题

## 第二篇 进程原理篇

### 第4章 进程

#### 4.1 进程概论

#### 4.2 进程模型

#### 4.3 多道编程的好处

#### 4.4 进程的产生与消亡

#### 4.5 进程的层次结构

#### 4.6 进程的状态

#### 4.7 进程与地址空间

#### 4.8 进程管理

#### 4.9 进程的缺陷

#### 思考题

### 第5章 进程调度

#### 5.1 进程调度的定义

#### 5.2 进程调度的目标

#### 5.3 先来先服务调度算法

#### 5.4 时间片轮转算法

#### 5.5 短任务优先算法

#### 5.6 优先级调度算法

#### 5.7 混合调度算法

#### 5.8 其他调度算法

#### 5.9 实时调度算法

#### 5.10 进程调度的过程

#### 5.11 高级议题：调度异常之优先级倒挂

#### 思考题

### 第6章 进程通信

#### 6.1 为什么要通信

#### 6.2 进程对白：管道、记名管道、套接字

#### 6.3 进程电报：信号

#### 6.4 进程旗语：信号量

#### 6.5 进程拥抱：共享内存

#### 6.6 信件发送：消息队列

#### 6.7 其他通信机制

#### 思考题

## 第三篇 线程原理篇

### 第7章 线程

#### 7.1 进程的分身术——线程

#### 7.2 线程管理

#### 7.3 线程模型的实现

#### 7.4 现代操作系统的线程实现模型

#### 7.5 多线程的关系

#### 7.6 讨论：从用户态进入内核态

#### 7.7 讨论：线程的困惑——确定性与非确定性

#### 思考题

### 第8章 线程同步

#### 8.1 为什么要同步

#### 8.2 线程同步的目的

#### 8.3 锁的进化：金鱼生存

#### 8.4 睡觉与叫醒：生产者与消费者问题

#### 8.5 信号量

#### 8.6 锁、睡觉与叫醒、信号量

#### 8.7 管程

#### 8.8 消息传递

#### 8.9 栅栏

#### 思考题

### 第9章 死锁应对之哲学原理

#### 9.1 为什么会发生死锁

#### 9.2 死锁的描述

#### 9.3 死锁的4个必要条件

#### 9.4 哲学家就餐问题

#### 9.5 死锁的应对

#### 9.6 消除死锁的必要条件

#### 9.7 银行家算法：冒险的代价

#### 9.8 哲学家就餐问题之解

#### 9.9 讨论：死锁的思考——综合治理

#### 9.10 讨论：死锁、活锁与饥饿

#### 思考题

### 第10章 锁的实现

#### 10.1 以中断启用与禁止来实现锁

#### 10.2 以测试与设置指令来实现锁

#### 10.3 以非繁忙等待、中断启用与禁止来实现锁

#### 10.4 以最少繁忙等待、测试与设置来实现锁

#### 10.5 中断禁止、测试与设置

#### 思考题

## 第四篇 内存原理篇

### 第11章 基本内存管理

#### 11.1 内存管理的环境

#### 11.2 内存管理的目标

#### 11.3 虚拟内存的概念

#### 11.4 操作系统在内存中的位置

#### 11.5 单道编程的内存管理

#### 11.6 多道编程的内存管理

#### 11.7 闲置空间管理

#### 思考题

### 第12章 页式内存管理

#### 12.1 基址极限管理模式的问题

#### 12.2 分页内存管理

#### 12.3 分页系统的优缺点

#### 12.4 翻译速度

#### 12.5 缺页中断处理

#### 12.6 锁住页面

#### 12.7 页面尺寸

#### 12.8 内存抖动

#### 思考题

### 第13章 页面更换算法

#### 13.1 页面需要更换

#### 13.2 页面更换的目标

#### 13.3 随机更换算法

#### 13.4 先进先出算法

#### 13.5 第二次机会算法

#### 13.6 时钟算法

#### 13.7 最优更换算法

#### 13.8 NRU算法

#### 13.9 LRU算法

#### 13.10 工作集算法

#### 13.11 工作集时钟算法

#### 13.12 页面替换策略

#### 思考题

### 第14章 段式内存管理

#### 14.1 分页系统的缺点

#### 14.2 分段管理系统

#### 14.3 分段的优缺点

#### 14.4 段页式内存管理

#### 14.5 段号是否占用寻址字位

#### 14.6 讨论：否定之否定的嵌套——纯粹分段与逻辑分段、分页与段页

#### 思考题

## 第五篇 文件原理篇

### 第15章 磁盘操作

#### 15.1 磁盘组织与管理

#### 15.2 磁盘的结构

#### 15.3 盘面的结构

#### 15.4 磁盘驱动器的访问速度

#### 15.5 操作系统界面

#### 15.6 磁盘调度算法

#### 15.7 讨论：固态盘

#### 15.8 讨论：智能磁盘系统

#### 思考题

### 第16章 文件系统

#### 16.1 为什么需要文件系统

#### 16.2 文件系统

#### 16.3 文件系统的目标

#### 16.4 文件的基本知识

#### 16.5 从用户角度看文件系统

#### 16.6 地址独立的实现机制：文件夹

#### 16.7 文件系统调用

#### 16.8 内存映射的文件访问

#### 思考题

### 第17章 文件系统实现

#### 17.1 文件系统的布局

#### 17.2 文件的实现

#### 17.3 目录实现：地址独立的实现

#### 17.4 闲置空间管理

#### 思考题

### 第18章 文件系统性能

#### 18.1 文件授权管理

#### 18.2 主动控制：访问控制表

#### 18.3 能力表

#### 18.4 访问控制的实施

#### 18.5 其他文件安全措施

#### 18.6 文件系统性能

#### 18.7 文件系统效率性能

#### 18.8 文件系统设计分析：日志结构的文件系统

#### 18.9 海量数据文件系统

#### 思考题

## 第六篇 1/O原理篇

### 第19章 输入输出

#### 19.1 输入输出

#### 19.2 输入输出的目的

#### 19.3 输入输出硬件

#### 19.4 I/O软件

#### 19.5 I/O软件分层

#### 思考题

## 第七篇 多核原理篇

### 第20章 多核结构与内存

#### 20.1 以量取胜

#### 20.2 多核基本概念

#### 20.3 多核的内存结构

#### 20.4 对称多处理器计算机的启动过程

#### 20.5 多处理器之间的通信

#### 20.6 SMP缓存一致性

#### 20.7 多处理器、超线程和多核的比较

#### 思考题

### 第21章 多核环境下的进程同步与调度

#### 21.1 多核环境下操作系统的修正

#### 21.2 多核环境下的进程同步与调度

#### 21.3 多核进程同步

#### 21.4 硬件原子操作

#### 21.5 总线锁

#### 21.6 多核环境下的软件同步原语

#### 21.7 旋锁

#### 21.8 其他同步原语

#### 21.9 多核环境下的进程调度

#### 21.10 多核环境下的能耗管理

#### 21.11 讨论：多核系统的性能

#### 思考题

## 第八篇 操作系统设计篇

### 第22章 操作系统设计之哲学原理

#### 22.1 操作系统设计的追求

#### 22.2 操作系统设计的第1条哲学原理：层次架构

#### 22.3 操作系统设计的第2条哲学原理：没有对错

> [!NOTE] 
> 其中的每一种树都有其使用的场景，但却没有对错之分。在使用红黑树的场景下当然可以使用伸展树或费波拉齐亚树，不会造成正确性的改变，只不过效率有可能不一样
> 
> 2022-02-15 13:20:34 ^603095-224-959-1033

#### 22.4 操作系统设计的第3条哲学原理：懒人哲学

> [!NOTE] 
> 很多人都会有一种习惯，就是一件事情不到迫不得已时是不会去做的
> 
> 2022-02-15 13:21:00 ^603095-225-522-552

> [!NOTE] 
> ，在fork后，系统里面将出现两个一模一样的进程，执行一样的功能，只不过其进程ID不同，执行的序列顺序不同
> 
> 2022-02-15 13:22:30 ^603095-225-763-816

> [!NOTE] 
> 那么将父进程地址空间的内容拷贝到子进程地址空间显然就是一种浪费。而造成这种浪费是因为我们做事情太积极，还没有搞清楚子进程的用途时就将父进程拷贝到子进
> 
> 2022-02-15 13:27:53 ^603095-225-1359-1433

> [!NOTE] 
> 在fork时只创建一个空的子进程，而不进行父子进程地址空间的拷贝
> 
> 2022-02-15 13:28:27 ^603095-225-1491-1523

> [!NOTE] 
> 这种不到万不得已不拷贝在计算机术语里面称为懒惰或延迟的拷贝（lazy copy）
> 
> 2022-02-15 13:28:46 ^603095-225-1725-1765

#### 22.5 操作系统设计的第4条哲学原理：让困于人

> [!NOTE] 
> 操作系统会使用各种原语操作保证文件系统的一致性，但这仅限于文件系统的元数据，而不是平面数据（用户数据）。即操作系统只对目录夹的操作进行原语保护，而对用户数据的操作通常不会采用这种保护措施
> 
> 2022-02-15 13:29:54 ^603095-226-699-792

#### 22.6 操作系统设计的第5条哲学原理：留有余地

#### 22.7 操作系统设计的第6条哲学原理：子虚乌有——海市蜃楼之美

#### 22.8 操作系统设计的第7条哲学原理：时空转换——沧海桑田之变

#### 22.9 操作系统设计的第8条哲学原理：策机分离与权利分离

#### 22.10 操作系统设计的第9条哲学原理：简单为美——求于至简，归于永恒

#### 22.11 操作系统设计的第10条哲学原理：适可而止

#### 思考题

## 结语：失望与希望

## 参考文献


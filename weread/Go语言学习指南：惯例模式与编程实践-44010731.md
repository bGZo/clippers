---
doc_type: weread-highlights-reviews
bookId: "44010731"
reviewCount: 0
noteCount: 5
author:
  - 乔恩·博德纳
  - 机械工业出版社
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/731/44010731/t7_44010731.jpg
readingStatus: 在读
progress: 6%
totalReadDay: 2
readingTime: 0小时10分钟
readingDate: 2024-06-17
title: Go语言学习指南：惯例模式与编程实践
published: 2022-04-01 00:00:00
isbn: 9787111703839
tags:
  - weread/计算机-编程设计
type: weread-notes
weread: https://weread.qq.com/web/reader/45a32c20729f8ceb45aa6fe

---


## 封面

## 版权信息

## 关于作者

## 关于封面

## O'Reilly Media, Inc介绍

## 本书赞誉

## 推荐序

## 译者序

## 前言

> [!NOTE] 
> Go语言编写程序确实很无趣。
> 
> 2024-06-24 22:10:58 ^44010731-9-447-461

> [!NOTE] 
> Go语言没有继承，没有泛型（目前还没有），没有面向切面的编程（aspect-oriented programming），没有函数重载，没有操作符重载，没有模式匹配，没有命名参数，没有异常。让很多人望而生畏的是，Go竟然有指针。Go的并发模型也与其他语言不同，但它基于20世纪70年代的思想，其垃圾收集器使用的算法也是如此。简言之，Go有些复古，而这正是关键所在。
> 
> 2024-06-24 22:11:40 ^44010731-9-574-755

> [!NOTE] 
> 本书中使用以下排版约定：斜体（Italic）表示新的术语、URL、电子邮件地址、文件名和文件扩展名。等宽字体（Constant width）用于程序清单，以及段落中的程序元素，例如变量名、函数名、数据库、数据类型、环境变量、语句以及关键字。等宽粗体（Constant width bold）表示应由用户直接输入的命令或其他文本。等宽斜体（Constant width italic）表示应由用户提供的值或由上下文确定的值替换的文本。
> 
> 2024-06-24 22:14:10 ^44010731-9-1855-2526

> [!NOTE] 
> 我们在Twitter上的地址：http://twitter.com/oreillymedia我们在YouTube上的地址：http://www.youtube.com/oreillymedia
> 
> 2024-06-24 22:25:26 ^44010731-9-5396-5662

> [!NOTE] 
> 感谢我的家人容忍我每个夜晚和周末都在计算机前度过，而不是陪伴他们。特别感谢我的妻子Laura，当我凌晨1点或更晚才上床睡觉时，她总是贴心地假装没有被我吵醒。
> 
> 2024-06-24 22:26:08 ^44010731-9-6358-6436

## 第1章 设置Go语言的开发环境

### 1.1 安装Go工具

### 1.2 Go的工作空间

### 1.3 Go命令集

### 1.4 分析与审查

### 1.5 选择开发工具

### 1.6 Makefile

### 1.7 保持更新

### 1.8 总结

## 第2章 基础类型和变量声明

### 2.1 内置类型

### 2.2 var与:=

### 2.3 const关键字

### 2.4 有类型的常量与无类型的常量

### 2.5 未使用的变量

### 2.6 常量与变量的命名

### 2.7 总结

## 第3章 复合类型

### 3.1 数组

### 3.2 切片

### 3.3 字符串、字符和字节

### 3.4 映射

### 3.5 结构体

### 3.6 总结

## 第4章 代码块、影子变量和流程控制

### 4.1 代码块

### 4.2 if语句

### 4.3 for语句

### 4.4 switch语句

### 4.5 默认的switch语句

### 4.6 if和switch之间的选择

### 4.7 goto语句

### 4.8 总结

## 第5章 函数

### 5.1 函数的声明和调用

### 5.2 函数即值

### 5.3 闭包

### 5.4 defer

### 5.5 函数的值调用

### 5.6 总结

## 第6章 指针

### 6.1 指针快速入门

### 6.2 不畏惧指针

### 6.3 指针即可变的参数

### 6.4 指针作为第二选择

### 6.5 指针传递可提高性能

### 6.6 零值与无值

### 6.7 映射与切片的区别

### 6.8 切片用作缓冲区

### 6.9 优化垃圾回收

### 6.10 总结

## 第7章 类型、方法与接口

### 7.1 Go语言的类型

### 7.2 方法

### 7.3 使用内嵌进行组合

### 7.4 内嵌不是继承

### 7.5 接口概览

### 7.6 接口是类型安全的鸭子类型

### 7.7 内嵌与接口

### 7.8 接收接口，返回结构体

### 7.9 接口与nil

### 7.10 空接口

### 7.11 类型断言与type-switch

### 7.12 谨慎使用类型断言与type-switch

### 7.13 函数类型实现接口

### 7.14 隐式接口实现依赖注入

### 7.15 Wire

### 7.16 Go并非传统意义上的面向对象语言

### 7.17 总结

## 第8章 错误

### 8.1 如何处理错误

### 8.2 使用字符串创建简单错误

### 8.3 哨兵错误

### 8.4 错误是值

### 8.5 包装错误

### 8.6 Is和As

### 8.7 使用defer包装错误

### 8.8 panic和recover

### 8.9 从错误中获取堆栈跟踪信息

### 8.10 总结

## 第9章 模块、包和导入

### 9.1 仓库、模块和包

### 9.2 go.mod

### 9.3 创建包

### 9.4 模块

### 9.5 模块的发布

### 9.6 模块的版本控制

### 9.7 模块代理服务器

### 9.8 总结

## 第10章 Go的并发编程

### 10.1 何时使用并发编程

### 10.2 goroutine

### 10.3 通道

### 10.4 select语句

### 10.5 并发实践与模式

### 10.6 何时使用互斥锁

### 10.7 atomic

### 10.8 额外资源

### 10.9 总结

## 第11章 Go语言标准库

### 11.1 标准io库

### 11.2 time

### 11.3 encoding/json

### 11.4 net/http

### 11.5 总结

## 第12章 上下文

### 12.1 什么是上下文

### 12.2 取消

### 12.3 计时器

### 12.4 在上下文中处理取消请求

### 12.5 传递值

### 12.6 总结

## 第13章 测试

### 13.1 测试的基本知识

### 13.2 表格驱动测试

### 13.3 检查代码覆盖率

### 13.4 基准测试

### 13.5 Go中的测试桩

### 13.6 httptest

### 13.7 集成测试和编译标签

### 13.8 使用竞争检测器检查并发问题

### 13.9 总结

## 第14章 恶龙禁区：反射、unsafe和cgo

### 14.1 在运行时使用反射处理类型

### 14.2 unsafe意味着不安全

### 14.3 cgo用于集成，而不是为了性能

### 14.4 总结

## 第15章 展望未来：Go中的泛型

### 15.1 泛型减少冗余代码，提高类型安全性

### 15.2 Go中的泛型

### 15.3 类型列表可指定操作符

### 15.4 泛型函数抽象算法

### 15.5 类型列表限制常量和实现

### 15.6 暂不考虑的问题

### 15.7 惯例模式与泛型

### 15.8 未来更多可能

### 15.9 总结


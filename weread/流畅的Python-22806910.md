---
doc_type: weread-highlights-reviews
bookId: "22806910"
reviewCount: 0
noteCount: 10
author:
  - 【巴】卢西亚诺·拉马略
  - 人民邮电出版社
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/910/22806910/t7_22806910.jpg
readingStatus: 在读
progress: 2%
totalReadDay: 3
readingTime: 0小时34分钟
readingDate: 2024-05-14
title: 流畅的Python
published: 2017-05-01 00:00:00
isbn: 9787115454157
tags:
  - weread/计算机-编程设计
type: weread-notes
weread: https://weread.qq.com/web/reader/ab832620715c017eab864a6

---


## 封面

## 版权信息

## O'Reilly Media, Inc.介绍

## 前言

## 第一部分 序幕

> [!NOTE] 
> 如果完整地说出“下划线－下划线－ getitem －下划线－下划线”，又会很麻烦。于是我跟着Steve Holden，一位技术书作者和老师，学会了“双下－ getitem”（dunder-getitem）这种说法。于是乎，特殊方法也叫双下方法（dunder method）
> 
> 2024-05-16 07:31:02 ^22806910-5-2450-2612

> [!NOTE] 
> ranks = [str(n) for n in range(2, 11)]+list('JQKA')    suits = 'spades diamonds clubs hearts'.split（　）
> 
> 2024-05-16 07:35:56 ^22806910-5-3270-3374

> [!NOTE] 
> 由__getitem__方法
> 
> 2024-05-16 07:37:08 ^22806910-5-4240-4254

> [!NOTE] 
> 作为你的类的用户，他们不必去记住标准操作的各式名称（“怎么得到元素的总数？是.size（　）还是.length（　）还是别的什么？”）。
> 
> 2024-05-16 07:42:38 ^22806910-5-4824-4892

> [!NOTE] 
> 因为__getitem__方法把[]操作交给了self._cards列表，所以我们的deck类自动支持切片（slicing）操作
> 
> 2024-05-16 07:42:53 ^22806910-5-5038-5102

> [!NOTE] 
> 仅仅实现了__getitem__方法，这一摞牌就变成可迭代的了
> 
> 2024-05-16 07:43:35 ^22806910-5-5493-5524

> [!NOTE] 
> 过长的内容就会被如上面例子的最后一行的省略号（...）所替代。此时就需要#doctest:+ELLIPSIS这个指令来保证doctest能够通过。
> 
> 2024-05-16 19:39:51 ^22806910-5-6226-6299

> [!NOTE] 
> 迭代通常是隐式的，譬如说一个集合类型没有实现__contains__方法，那么in运算符就会按顺序做一次迭代搜索
> 
> 2024-05-16 19:41:42 ^22806910-5-6357-6413

> [!NOTE] 
> 黑桃最大、红桃次之、方块再次、梅花最小
> 
> 2024-05-16 19:42:14 ^22806910-5-6641-6660

> [!NOTE] 
> 通过实现__len__和__getitem__这两个特殊方法，FrenchDeck就跟一个Python自有的序列数据类型一样，可以体现出Python的核心语言特性（例如迭代和切片）
> 
> 2024-05-16 19:45:06 ^22806910-5-7529-7619

## 第二部分 数据结构

### 第3章 字典和集合

### 第4章 文本和字节序列

## 第三部分 把函数视作对象

### 第6章 使用一等函数实现设计模式

### 第7章 函数装饰器和闭包

## 第四部分 面向对象惯用法

### 第9章 符合Python风格的对象

### 第10章 序列的修改、散列和切片

### 第11章 接口：从协议到抽象基类

### 第12章 继承的优缺点

### 第13章 正确重载运算符

## 第五部分 控制流程

### 第15章 上下文管理器和else块

### 第16章 协程

### 第17章 使用future处理并发

### 第18章 使用asyncio包处理并发

## 第六部分 元编程

### 第20章 属性描述符

### 第21章 类元编程

## 结语

## 附录A 辅助脚本

## Python术语表

## 作者简介

## 关于封面


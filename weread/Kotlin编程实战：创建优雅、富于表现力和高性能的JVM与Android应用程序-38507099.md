---
doc_type: weread-highlights-reviews
bookId: "38507099"
reviewCount: 0
noteCount: 12
author:
  - 文卡特·苏布拉马尼亚姆
  - 机械工业出版社
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/99/38507099/t7_38507099.jpg
readingStatus: 在读
progress: 7%
totalReadDay: 4
readingTime: 0小时29分钟
readingDate: 2024-08-05
title: Kotlin编程实战：创建优雅、富于表现力和高性能的JVM与Android应用程序
published: 2021-06-01 00:00:00
isbn: 9787111682752
tags:
  - weread/计算机-编程设计
type: weread-notes
weread: https://weread.qq.com/web/reader/376323a0724b925b376fe83

---


## 封面

## 版权页

## 本书赞誉

## 序

## 前言

> [!NOTE] 
> 命令式风格在大型应用程序中更好
> 
> 2024-08-06 20:34:50 ^38507099-5-942-957

> [!NOTE] 
> 当编写面向对象的代码时，你将看到编译器是在为你工作，而不是你在为编译器工作
> 
> 2024-08-06 20:35:15 ^38507099-5-1064-1101

> [!NOTE] 
> 在Kotlin中，函数是“一等公民”，
> 
> 2024-08-06 20:36:12 ^38507099-5-2167-2186

> [!NOTE] 
> 在命令式编程中，我们经常使用外部迭代器。
> 
> 2024-08-06 20:36:18 ^38507099-5-2257-2277

## 致谢

## 第1章 你好Kotlin

> [!NOTE] 
> Kotlin是俄罗斯圣彼得堡附近的一个小岛的名称，这本书是关于它的同名编程语言的。
> 
> 2024-08-06 20:38:14 ^38507099-7-378-419

> [!NOTE] 
> 委托通常是比继承更好的重用代码的设计工具
> 
> 2024-08-06 20:39:43 ^38507099-7-1700-1720

### 1.1 爱上Kotlin的理由

#### 1.1.1 多范式编程

#### 1.1.2 具有类型推断的静态类型

### 1.2 为什么选择Kotlin

### 1.3 带Kotlin去兜兜风

#### 1.3.1 安装Kotlin SDK

> [!NOTE] 
> 我们都使用IDE，但最好从如何在命令行上编译和运行开始学习，因为这会让你充分了解如何构建代码。
> 
> 2024-08-06 20:43:26 ^38507099-13-535-582

#### 1.3.2 验证安装

### 1.4 编译成字节码并运行

#### 1.4.1 在命令行上运行

> [!NOTE] 
> Hello.kt中的代码编译为Java字节码
> 
> 2024-08-06 20:47:02 ^38507099-16-585-607

> [!NOTE] 
> 在找到main()函数之后，Kotlin编译器决定将Main-Class manifest（清单）属性添加到jar文件中
> 
> 2024-08-06 20:48:44 ^38507099-16-1191-1251

#### 1.4.2 在IDE中运行

#### 1.4.3 使用REPL进行实验

> [!NOTE] 
> 使用人们发明的最佳工具——复制和粘贴——将其从REPL放到编辑器或IDE中。
> 
> 2024-08-06 20:49:13 ^38507099-18-513-551

> [!NOTE] 
> 在REPL中，还可以加载现有文件来执行其中的代码。例如，加载我们之前创建的Hello.kt文件，并在REPL中运行，这不需要执行显式的编译步骤。
> 
> 2024-08-06 20:50:40 ^38507099-18-1061-1133

#### 1.4.4 作为脚本运行

> [!NOTE] 
> 可以使用Kotlin编写脚本。这样做的好处是，你不必记住sh、zsh、bash、Windows CMD、PowerShell等shell命令，可以使用一种强大而流畅的语言来完成任务。一旦在Kotlin中实现了所需的任务，就可以将其作为脚本来运行，只需一步，而不用显式地编译代码来创建字节码。
> 
> 2024-08-06 20:51:20 ^38507099-19-579-724

### 1.5 编译成其他目标

### 1.6 选择哪个选项

### 1.7 本章小结

## 第一部分 使用Kotlin编写脚本

### 第2章 从Java角度了解Kotlin的基本知识

#### 2.1 减少输入









#### 2.2 合理的警告

#### 2.3 选择val而不是var

#### 2.4 改进的相等性检查

#### 2.5 字符串模板

#### 2.6 原始字符串





#### 2.7 更多的表达式，更少的语句

#### 2.8 本章小结

### 第3章 使用函数

#### 3.1 创建函数











#### 3.2 默认参数和命名参数





#### 3.3 vararg和spread





#### 3.4 解构

#### 3.5 本章小结

### 第4章 外部迭代和参数匹配

#### 4.1 范围与迭代









#### 4.2 遍历数组和列表

#### 4.3 何时应该使用when







#### 4.4 本章小结

### 第5章 使用集合

#### 5.1 集合的类型





#### 5.2 使用Pair和Triple

#### 5.3 对象和基元数组

#### 5.4 使用列表

#### 5.5 使用集合

#### 5.6 使用映射

#### 5.7 本章小结

### 第6章 使用类型安全性解决问题

#### 6.1 Any和Nothing类





#### 6.2 可空的引用













#### 6.3 类型检查和转换









#### 6.4 显式类型转换

#### 6.5 泛型：参数类型的变化和约束











#### 6.6 具体化的类型参数

#### 6.7 本章小结

## 第二部分 面向对象的Kotlin

### 第7章 对象和类

#### 7.1 对象和单例







#### 7.2 创建类











#### 7.3 伴生对象和类成员









#### 7.4 创建泛型类

#### 7.5 数据类

#### 7.6 本章小结

### 第8章 类层次结构和继承

#### 8.1 创建接口和抽象类







#### 8.2 嵌套类和内部类

#### 8.3 继承

#### 8.4 Sealed类

#### 8.5 创建和使用枚举

#### 8.6 本章小结

### 第9章 通过委托进行扩展

#### 9.1 何时选择委托而不是继承

#### 9.2 使用委托进行设计









#### 9.3 委托给一个参数

#### 9.4 处理方法冲突

#### 9.5 Kotlin委托的注意事项

#### 9.6 委托变量和属性





#### 9.7 内置的标准委托







#### 9.8 本章小结

## 第三部分 函数式Kotlin

### 第10章 使用lambda进行函数式编程

#### 10.1 函数式风格





#### 10.2 lambda表达式















#### 10.3 lambda和匿名函数

#### 10.4 闭包和词法作用域

#### 10.5 非局部和带标签的return







#### 10.6 带有lambda的内联函数













#### 10.7 本章小结

### 第11章 内部迭代和延迟计算

#### 11.1 外部迭代器与内部迭代器

#### 11.2 内部迭代器











#### 11.3 延迟计算序列





#### 11.4 本章小结

## 第四部分 优雅且高效的Kotlin

### 第12章 Kotlin的流畅性

#### 12.1 重载运算符

#### 12.2 使用扩展函数和属性进行注入













#### 12.3 扩展函数

#### 12.4 带中缀的函数流畅性

#### 12.5 带Any对象的流畅性













#### 12.6 隐式接收方





#### 12.7 本章小结

### 第13章 创建内部DSL

#### 13.1 DSL的类型和特征





#### 13.2 用于内部DSL的Kotlin













#### 13.3 构建流畅性方面的挑战





#### 13.4 类型安全构建器





#### 13.5 使用作用域控制来缩小访问范围

#### 13.6 本章小结

### 第14章 编写递归和记忆

#### 14.1 递归的威力和危险

#### 14.2 尾调用优化

#### 14.3 记忆







#### 14.4 将记忆应用于动态规划

#### 14.5 本章小结

## 第五部分 编写异步应用程序

### 第15章 探索协程

#### 15.1 协程和并发





#### 15.2 使用协程并发运行









#### 15.3 协程上下文和线程









#### 15.4 调试协程





#### 15.5 创建无限序列





#### 15.6 本章小结

### 第16章 异步编程

#### 16.1 非阻塞异步编程





#### 16.2 异常处理





#### 16.3 取消和超时











#### 16.4 本章小结

## 第六部分 互操作和测试

### 第17章 将Java与Kotlin混合使用

#### 17.1 联合编译

#### 17.2 从Kotlin调用Java

#### 17.3 从Java调用Kotlin















#### 17.4 本章小结

### 第18章 使用Kotlin进行单元测试

#### 18.1 被测试的代码

#### 18.2 获取项目文件





#### 18.3 从Canary测试开始

#### 18.4 编写经验测试

#### 18.5 编写数据驱动的测试

#### 18.6 模拟依赖项





#### 18.7 测试顶级函数

#### 18.8 测试协程和异步调用

#### 18.9 与服务集成

#### 18.10 查看代码覆盖率

#### 18.11 将应用程序用于驱动

#### 18.12 本章小结

### 第19章 使用Kotlin编写Spring应用程序

#### 19.1 创建一个Starter项目

#### 19.2 创建一个控制器

#### 19.3 创建一个实体类

#### 19.4 创建一个存储库接口

#### 19.5 创建一个服务

#### 19.6 将服务与控制器集成

#### 19.7 继续实践

#### 19.8 本章小结

### 第20章 使用Kotlin编写Android应用程序

#### 20.1 创建一个项目

#### 20.2 定义域对象

#### 20.3 创建布局

#### 20.4 实施活动

#### 20.5 更新RecyclerView

#### 20.6 查看应用程序的运行情况

#### 20.7 本章小结

## 附录1 转换为JavaScript

## 附录2 Kotlin/Native

## 附录3 Kotlin到WebAssembly

## 参考文献


---
title: 今天有个面试官和我讲-go-的协程比系统的线程更慢-这个我不能理解
created: 2025-03-24T20:14:35
modified: 2025-03-24T20:45:03
source: https://www.v2ex.com/t/1120244#reply37
tags: 
tags-link:
  - "[[golang]]"
type: archive-web
---

## Origin Content

我不知道他的回答和我的回答哪个是有依据的，麻烦有大佬知道的，指正我一下，仅是探讨技术对错问题，谢谢。

他一上来问我 go 的协程能否做到线程不能做到的事，而且至少重复问了我 3 次。我回：总的来说是可以加快程序的运行效率。他就讲出了他的理论和依据，既然 go 协程是要由线程去接管运行的，资源也是从线程分来的，那么何谈加快运行效率，你原本线程要做的事还是没变，而且还多了管理协程的开销。后来他又提了一些问题试图来让我相信他这个理论和依据，不知道其中某个问题的时候，我回的是：不耗费资源的操作时，协程要更快，在耗费资源较多时，还是线程更快。然后他还是在反复和我纠结这个问题。在我看来 go 的协程实现是分割原本线程的资源，做到更轻量化和更灵活的资源调度。调用完资源空闲了就可以及时 gc ，就可以用更少的资源去做更多的事。到最后，他才说，我的大前提是，要做的事是非常耗费资源的操作，就感觉很搞不懂。

虽然我面试问题回答的很差，但是我依旧想知道这个问题，不知道有没有大佬来和我指正一下，

另外他还有第二个问题，既然协程这套理论这么牛逼，那么 c++ 为什么没有呢？（在我印象里 c++ 只有线程）

## Comment

\> 在我看来 go 的协程实现是分割原本线程的资源，做到更轻量化和更灵活的资源调度

没什么问题。更具体地说，很重要的一个原因是 userspace thread 完全省略了操作系统调度线程和内核态切换的开销。

有一个类似的例子：为什么 C 语言里用 malloc() 分配内存，而不是直接调操作系统提供的 sbrk()？你让面试官想去吧。

\> 他还有第二个问题，既然协程这套理论这么牛逼，那么 c++ 为什么没有呢

没更新过知识的愚昧认知。当今几乎所有现代语言里都有「协程」，只是具体含义和实现不同。我随便抓一把：Python 、JS/TS 、C++、Rust 、C#、Java/Kotlin 、Lua 、Dart…

还有个老生常谈的称呼问题：

协程 = 有栈协程/虚拟线程/用户态线程。这是在说 Go 的 goroutinue 、Java 的 Virtual Thread ；

协程 = 无栈协程/暂停之后能恢复的函数。这是在说 Python/Dart 的 Iterator 、Lua/C++20 的 Coroutines 、Rust 的 Future 状态机；

协程 = 可以指包装了一层 Dispatcher 的普通线程。这是在说 Kotlin 的 Coroutine + NewThreadDispatcher 。

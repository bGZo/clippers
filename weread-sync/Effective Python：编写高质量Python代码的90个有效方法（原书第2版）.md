---
doc_type: weread-highlights-reviews
bookId: "39980417"
reviewCount: 0
noteCount: 15
author:
  - 布雷特·斯拉特金
  - 机械工业出版社
cover: https://cdn.weread.qq.com/weread/cover/79/YueWen_39980417/t7_YueWen_39980417.jpg
readingStatus: 在读
progress: 13%
totalReadDay: 6
readingTime: 1小时6分钟
readingDate: 2022-06-16
title: Effective Python：编写高质量Python代码的90个有效方法（原书第2版）
published: 2021-01-01 00:00:00
description: 本书可以帮你掌握真正的Pythonic编程方式，令你能够完全发挥出Python语言的强大功能，并写出健壮而高效的代码。Scott Meyers在畅销书《Effective C++》中开创了一种以使用场景为主导的精练教学方式，本书作者Brett Slatkin就以这种方式汇聚了90条实践原则、开发技巧和便捷方案，并以实用的代码范例来解释它们。Slatkin根据自己在Google公司多年开发Python基础架构所积累的经验，揭示Python语言中一些鲜为人知的微妙特性，并给出了能够改善代码功能及运行效率的习惯用法。通过本书，你能够了解到解决关键编程任务所用的奇妙方式，并学会编写易于理解、便于维护且利于改进的代码。
isbn: 9787111674023
tags:
  - 计算机-编程设计
type: weread-notes
weread: https://weread.qq.com/web/reader/c2932f9072620d81c29c1ed

---


## 封面

## 版权信息

## 本书赞誉

## 译者序

## 前言

## 致谢

## 第1章 培养Pythonic思维

### 第1条 查询自己使用的Python版本

### 第2条 遵循PEP 8风格指南

### 第3条 了解bytes与str的区别

### 第4条 用支持插值的f-string取代C风格的格式字符串与str.format方法

> [!NOTE] 
> 这个操作符左边的文本模板叫作格式字符串（format string），我们可以在操作符右边写上某个值或者由多个值所构成的元组（tuple），用来替换格式字符串里的相关符号
> 
> 2023-02-15 11:20:09 ^39980417-11-823-908

> [!NOTE] 
> C风格的格式字符串，在Python里有四个缺点。第一个缺点是，如果%右侧那个元组里面的值在类型或顺序上有变化，那么程序可能会因为转换类型时发生不兼容问题而出现错误
> 
> 2023-02-15 11:23:06 ^39980417-11-1812-1951

> [!NOTE] 
> 第二个缺点是，在填充模板之前，经常要先对准备填写进去的这个值稍微做一些处理，但这样一来，整个表达式可能就会写得很长，让人觉得比较混乱
> 
> 2023-02-15 11:26:33 ^39980417-11-3050-3116

> [!NOTE] 
> 为了解决上面提到的一些问题，Python的%操作符允许我们用dict取代tuple
> 
> 2023-02-15 11:25:32 ^39980417-11-4867-5036

> [!NOTE] 
> 内置的format函数与str类的format方法
> 
> 2023-02-15 11:27:36 ^39980417-11-7536-7561

> [!NOTE] 
> 在传给format函数的格式里面，逗号表示显示千位分隔符，^表示居中对齐。
> 
> 2023-02-15 11:28:27 ^39980417-11-7855-7937

> [!NOTE] 
> 在Python解释器里输入help('FORMATTING')，可以详细查看str.format使用的这套格式说明符所依据的规则
> 
> 2023-02-15 11:33:16 ^39980417-11-8995-9149

> [!NOTE] 
> 这种{}形式的说明符，还支持一些比较高级的用法，例如可以查询dict中某个键的值，可以访问list里某个位置的元素，还可以把值转化成Unicode或repr字符串。下面这段代码把这三项特性结合了起来
> 
> 2023-02-15 11:34:16 ^39980417-11-12401-12680

> [!NOTE] 
> 我们就来看看f-string为什么比前面几种办法都要强大
> 
> 2023-02-15 11:35:18 ^39980417-11-14106-14134

> [!NOTE] 
> 直接在f-string的{}里面引用当前Python范围内的所有名称，进而达到简化的目的
> 
> 2023-02-15 11:36:07 ^39980417-11-14763-14852

> [!NOTE] 
> 通过!符号把值转化成Unicode及repr形式的字符串
> 
> 2023-02-15 11:39:56 ^39980417-11-15321-15394

> [!NOTE] 
> ，f-string可以简洁而清晰地表达出许多种逻辑，这使它成为程序员的最佳选择。如果你想把值以适当的格式填充到字符串里面，那么首先应该考虑的就是采用f-string来实现
> 
> 2023-02-15 11:41:19 ^39980417-11-17404-17489

### 第5条 用辅助函数取代复杂的表达式

> [!NOTE] 
> 辅助函数
> 
> 2023-02-15 11:18:33 ^39980417-12-4653-4657

> [!NOTE] 
> 即使像下面这个例子一样只用两三次，也还是值得这样做
> 
> 2023-02-15 11:18:43 ^39980417-12-4661-4686

> [!NOTE] 
> 语法简洁的Python虽然可以写出很多浓缩的句式，但应该避免让这样的写法把表达式弄得太复杂。我们要遵循DRY原则，也就是不要重复自己写过的代码（Don't Repeat Yourself）
> 
> 2023-02-15 11:19:09 ^39980417-12-5412-5506

### 第6条 把数据结构直接拆分到多个变量里，不要专门通过下标访问

### 第7条 尽量用enumerate取代range

### 第8条 用zip函数同时遍历两个迭代器

### 第9条 不要在for与while循环后面写else块

### 第10条 用赋值表达式减少重复代码

## 第2章 列表与字典

### 第11条 学会对序列做切片

### 第12条 不要在切片里同时指定起止下标与步进

### 第13条 通过带星号的unpacking操作来捕获多个元素，不要用切片

### 第14条 用sort方法的key参数来表示复杂的排序逻辑

### 第15条 不要过分依赖给字典添加条目时所用的顺序

### 第16条 用get处理键不在字典中的情况，不要使用in与KeyError

### 第17条 用defaultdict处理内部状态中缺失的元素，而不要用setdefault

### 第18条 学会利用__missing__构造依赖键的默认值

## 第3章 函数

### 第19条 不要把函数返回的多个数值拆分到三个以上的变量中

### 第20条 遇到意外状况时应该抛出异常，不要返回None

### 第21条 了解如何在闭包里面使用外围作用域中的变量

### 第22条 用数量可变的位置参数给函数设计清晰的参数列表

### 第23条 用关键字参数来表示可选的行为

### 第24条 用None和docstring来描述默认值会变的参数

### 第25条 用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表

### 第26条 用functools.wraps定义函数修饰器

## 第4章 推导与生成

### 第27条 用列表推导取代map与filter

### 第28条 控制推导逻辑的子表达式不要超过两个

### 第29条 用赋值表达式消除推导中的重复代码

### 第30条 不要让函数直接返回列表，应该让它逐个生成列表里的值

### 第31条 谨慎地迭代函数所收到的参数

### 第32条 考虑用生成器表达式改写数据量较大的列表推导

### 第33条 通过yield from把多个生成器连起来用

### 第34条 不要用send给生成器注入数据

### 第35条 不要通过throw变换生成器的状态

### 第36条 考虑用itertools拼装迭代器与生成器

## 第5章 类与接口

### 第37条 用组合起来的类来实现多层结构，不要用嵌套的内置类型

### 第38条 让简单的接口接受函数，而不是类的实例

### 第39条 通过@classmethod多态来构造同一体系中的各类对象

### 第40条 通过super初始化超类

### 第41条 考虑用mix-in类来表示可组合的功能

### 第42条 优先考虑用public属性表示应受保护的数据，不要用private属性表示

### 第43条 自定义的容器类型应该从collections.abc继承

## 第6章 元类与属性

### 第44条 用纯属性与修饰器取代旧式的setter与getter方法

### 第45条 考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码

### 第46条 用描述符来改写需要复用的@property方法

### 第47条 针对惰性属性使用__getattr__、__getattribute__及__setattr__

### 第48条 用__init_subclass__验证子类写得是否正确

### 第49条 用__init_subclass__记录现有的子类

### 第50条 用__set_name__给类属性加注解

### 第51条 优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类

## 第7章 并发与并行

### 第52条 用subprocess管理子进程

### 第53条 可以用线程执行阻塞式I/O，但不要用它做并行计算

### 第54条 利用Lock防止多个线程争用同一份数据

### 第55条 用Queue来协调各线程之间的工作进度

### 第56条 学会判断什么场合必须做并发

### 第57条 不要在每次fan-out时都新建一批Thread实例

### 第58条 学会正确地重构代码，以便用Queue做并发

### 第59条 如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现

### 第60条 用协程实现高并发的I/O

### 第61条 学会用asyncio改写那些通过线程实现的I/O

### 第62条 结合线程与协程，将代码顺利迁移到asyncio

### 第63条 让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力

### 第64条 考虑用concurrent.futures实现真正的并行计算

## 第8章 稳定与性能

### 第65条 合理利用try/except/else/finally结构中的每个代码块

### 第66条 考虑用contextlib和with语句来改写可复用的try/finally代码

### 第67条 用datetime模块处理本地时间，不要用time模块

### 第68条 用copyreg实现可靠的pickle操作

### 第69条 在需要准确计算的场合，用decimal表示相应的数值

### 第70条 先分析性能，然后再优化

### 第71条 优先考虑用deque实现生产者-消费者队列

### 第72条 考虑用bisect搜索已排序的序列

### 第73条 学会使用heapq制作优先级队列

### 第74条 考虑用memoryview与bytearray来实现无须拷贝的bytes操作

## 第9章 测试与调试

### 第75条 通过repr字符串输出调试信息

### 第76条 在TestCase子类里验证相关的行为

### 第77条 把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDownModule中，以防用例之间互相干扰

### 第78条 用Mock来模拟受测代码所依赖的复杂函数

### 第79条 把受测代码所依赖的系统封装起来，以便于模拟和测试

### 第80条 考虑用pdb做交互调试

### 第81条 用tracemalloc来掌握内存的使用与泄漏情况

## 第10章 协作开发

### 第82条 学会寻找由其他Python开发者所构建的模块

### 第83条 用虚拟环境隔离项目，并重建依赖关系

### 第84条 每一个函数、类与模块都要写docstring

### 第85条 用包来安排模块，以提供稳固的API

### 第86条 考虑用模块级别的代码配置不同的部署环境

### 第87条 为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常

### 第88条 用适当的方式打破循环依赖关系

### 第89条 重构时考虑通过warnings提醒开发者API已经发生变化

### 第90条 考虑通过typing做静态分析，以消除bug


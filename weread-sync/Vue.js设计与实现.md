---
doc_type: weread-highlights-reviews
bookId: "3300028078"
reviewCount: 0
noteCount: 18
author:
  - 霍春阳　著
  - 人民邮电出版社
cover: https://cdn.weread.qq.com/weread/cover/96/cpPlatform_kmqPY1boCDVyMxq2AvPdCY/t7_cpPlatform_kmqPY1boCDVyMxq2AvPdCY.jpg
readingStatus: 在读
progress: 4%
totalReadDay: 1
readingTime: 0小时28分钟
readingDate: 2022-12-13
title: Vue.js设计与实现
published: 2022-01-01 00:00:00
description: 本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。
isbn: 9787115583864
tags:
  - weread/计算机-软件学习
type: weread-notes
weread: https://weread.qq.com/web/reader/c5c32170813ab7177g0181ae

---


## 封面

## 版权信息

## 序

## 前言

## 第一篇 框架设计概览

### 第1章 权衡的艺术

> [!NOTE] 
> 视图层框架设计方面的内容
> 
> 2022-12-13 23:15:26 ^3300028078-6-483-495

> [!NOTE] 
> jQuery 就是典型的命令式框架。命令式框架的一大特点就是关注过程
> 
> 2022-12-13 23:16:47 ^3300028078-6-1058-1111

> [!NOTE] 
> 自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉
> 
> 2022-12-13 23:18:07 ^3300028078-6-1718-1765

> [!NOTE] 
> 我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心
> 
> 2022-12-13 23:19:59 ^3300028078-6-2040-2072

> [!NOTE] 
> Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式
> 
> 2022-12-13 23:20:25 ^3300028078-6-2211-2341

> [!NOTE] 
> 理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了
> 
> 2022-12-13 23:22:23 ^3300028078-6-2792-2838

> [!NOTE] 
> 为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是
> 
> 2022-12-13 23:22:40 ^3300028078-6-3098-3146

> [!NOTE] 
> 框架本身就是封装了命令式代码才实现了面向用户的声明式。这符合前文中给出的性能结论：声明式代码的性能不优于命令式代码的性能
> 
> 2022-12-13 23:23:07 ^3300028078-6-3501-3587

> [!NOTE] 
> 声明式代码的可维护性更强
> 
> 2022-12-13 23:23:22 ^3300028078-6-3674-3686

> [!NOTE] 
> 使用 innerHTML 操作页面和虚拟 DOM 相比性能如何？
> 
> 2022-12-13 23:30:48 ^3300028078-6-5081-5113

> [!NOTE] 
> HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量
> 
> 2022-12-13 23:32:34 ^3300028078-6-6131-6167

> [!NOTE] 
> innerHTML、虚拟 DOM 以及原生 JavaScript（指 createElement 等方法）在更新页面时的性能
> 
> 2022-12-13 23:34:45 ^3300028078-6-8333-8395

> [!NOTE] 
> 纯运行时的、运行时 + 编译时的或纯编译时的
> 
> 2022-12-13 23:35:07 ^3300028078-6-9333-9355

> [!NOTE] 
> 直接为 Render 函数提供了一个树型结构的数据对象
> 
> 2022-12-13 23:40:47 ^3300028078-6-10637-10664

> [!NOTE] 
> 既然编译器可以把 HTML 字符串编译成数据对象，那么能不能直接编译成命令式代码呢？
> 
> 2022-12-13 23:42:31 ^3300028078-6-11979-12021

> [!NOTE] 
> 没办法分析用户提供的内容
> 
> 2022-12-13 23:43:32 ^3300028078-6-12774-12786

> [!NOTE] 
> Svelte 就是纯编译时的框架，但是它的真实性能可能达不到理论高度
> 
> 2022-12-13 23:44:16 ^3300028078-6-13046-13080

### 第2章 框架设计的核心要素

> [!NOTE] 
> 热更新（hot module replacement，HMR）需要框架层面的支持，我们是否也应该考虑？
> 
> 2022-12-13 23:30:08 ^3300028078-7-565-623

### 第3章 Vue.js 3 的设计思路

## 第二篇 响应系统

### 第4章 响应系统的作用与实现

### 第5章 非原始值的响应式方案

### 第6章 原始值的响应式方案

## 第三篇 渲染器

### 第7章 渲染器的设计

### 第8章 挂载与更新

### 第9章 简单 Diff 算法

### 第10章 双端 Diff 算法

### 第11章 快速 Diff 算法

## 第四篇 组件化

### 第12章 组件的实现原理

### 第13章 异步组件与函数式组件

### 第14章 内建组件和模块

## 第五篇 编译器

### 第15章 编译器核心技术概览

### 第16章 解析器

### 第17章 编译优化

## 第六篇 服务端渲染

### 第18章 同构渲染

## 作者简介

## 看完了

